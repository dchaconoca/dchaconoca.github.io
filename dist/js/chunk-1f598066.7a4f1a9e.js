(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-1f598066"],{1152:function(e,a,n){e.exports=n.p+"img/ER-casa.7c71478e.png"},1551:function(e,a,n){e.exports=n.p+"img/BD-casa.bd0fee71.png"},"2d39":function(e,a,n){"use strict";n("9a1d")},"5a53":function(e,a,n){e.exports=n.p+"img/BD-receta.4d0bceb5.png"},"7c71":function(e,a,n){e.exports='<h1 id="¿cómo-construir-tu-base-de-datos-relacional">¿Cómo construir tu base de datos relacional?</h1>\n<h6 id="20102021---d-chacón-ocariz">20/10/2021 - D. Chacón Ocariz</h6>\n<p>SQL (por sus siglas en inglés Structured Query Language) es el lenguaje utilizado para crear, modificar y acceder la información de las bases de datos relacionales.  </p>\n<p>Es un lenguaje declarativo de alto nivel, es decir que, especificamos qué es lo que queremos y no cómo conseguirlo. Esto supone una manera particular de pensar al momento de resolver problemas con este lenguaje.</p>\n<h2 id="¿por-qué-es-importante-aprender-sql">¿Por qué es importante aprender SQL?</h2>\n<p>Vivimos en un mundo donde a cada instante se producen más y más datos. Esta información debe ser almacenada en algún lugar para luego ser tratada, visualizada, analizada... </p>\n<p>Las bases de datos relacionales son sistemas que nos permiten almacenar y manipular datos siguiendo el modelo relacional. Esto se logra a través del lenguaje SQL. Entre otras cosas, el SQL sirve para <em>hacerle preguntas</em> a una base de datos y obtener la información que deseamos.</p>\n<p>Y aunque el SQL sea característico de las bases de datos relacionales, comprenderlo también nos ayuda en la utilización y manipulación de bases de datos <em>not-only SQL</em>. </p>\n<p>Así que si te dedicas al desarrollo de aplicaciones, la ciencia de datos, o incluso si eres gerente o te dedicas al marketing (en general, si en tu trabajo manipulas datos), saber SQL te será de gran utilidad. Te ayudará a simplificar tu trabajo y te ahorrará tiempo, además de poder manipular cientos de miles o incluso millones de datos, con una sola instrucción y en relativamente poco tiempo.</p>\n<p>En este artículo y el siguiente, quiero enseñarte un método para que comprendas cómo hacer consultas con SQL a partir de un modelo relacional y de preguntas en lenguaje corriente. </p>\n<h2 id="el-modelo-entidad-relación">El Modelo Entidad-Relación</h2>\n<p>El <strong>Modelo Entidad-Relación</strong> (ER) se basa en una percepción del mundo real donde hay objetos básicos (<strong>Entidades</strong>) que se relacionan entre sí (<strong>Relaciones</strong>). Es una herramienta que se utiliza para el modelado de datos.</p>\n<p><strong>Entidad:</strong> Representa una <em>cosa</em>, <em>objeto</em> o <em>concepto</em> del mundo real con existencia independiente. Es un objeto sobre el que queremos almacenar información. Ejemplo: Un empleado, un departamento, una cuenta bancaria, una receta, un ingrediente, un artículo, un automóvil, un animal...</p>\n<p><strong>Atributos:</strong> Los atributos son las características que definen a una entidad.</p>\n<p>Una entidad está descrita y se representa por sus características o atributos. Por ejemplo: </p>\n<ol>\n<li>La entidad Persona tiene como características: Nombre, Apellido, Fecha de nacimiento, etc. </li>\n<li>La entidad Empleado tiene como características: Nombre, Apellido, Profesión, Puesto en la empresa, etc. </li>\n<li>La entidad Artículo tiene como características: Título, Fecha de publicación, Resumen, etc.</li>\n</ol>\n<p>Lo que hace única una entidad son los valores específicos de sus atributos, por ejemplo: Pedro Pérez y María González son entidades de tipo Persona.</p>\n<p><strong>Relación:</strong> Es la asociación entre entidades. Refleja las interacciones existentes entre ellas. Se describe a través de verbos: Vive en, Trabaja en, Está formado por, Realiza,...</p>\n<p><strong>Cardinalidad de las relaciones:</strong> Cardinalidad es el número de entidades con los cuales otra entidad puede asociarse. Puede ser: Cero a uno, cero a muchos, uno a uno, uno a muchos o muchos a uno, muchos a muchos:</p>\n<p><em>0</em> si cada instancia de la entidad no está obligada a participar en la relación.\n<em>1</em> si toda instancia de la entidad está obligada a participar en la relación y, además, solamente participa una vez.\n<em>N</em> o <em>M</em> si cada instancia de la entidad puede participar cualquier número de veces dentro de la relación (también se puede representar como N:M) </p>\n<p>Algunos ejemplos de modelos ER y su representación gráfica:</p>\n<ol>\n<li>Una <em>Casa</em> <em>es habitada</em> por una o varias <em>Personas</em>. Persona y Casa son <strong>entidades</strong>. <em>Es habitada</em> es la <strong>relación</strong> que las une: </li>\n</ol>\n<figure>\n    <img class="img-art" src="'+n("1152")+'" alt="Modelo ER Persona - Casa">\n    <figcaption class="titulo-img">Modelo ER Persona - Casa</figcaption>\n</figure>\n\n<ol start="2">\n<li>El <em>Artículo</em> de un blog <em>es ecrito</em> por un <em>Autor</em>. Un Autor puede escribir muchos Artículos. Un artículo es escrito por un autor. Artículo y Autor son las entidades. Escribir es el verbo que describe la relación</li>\n</ol>\n<figure>\n    <img class="img-art" src="'+n("d755")+'" alt="Modelo ER Artículo - Autor">\n    <figcaption class="titulo-img">Modelo ER Artículo - Autor</figcaption>\n</figure>\n\n<ol start="3">\n<li>Una <em>Receta</em> de cocina <em>contiene</em> varios ingredientes. Un mismo <em>Ingrediente</em> puede formar parte de varias Recetas</li>\n</ol>\n<figure>\n    <img class="img-art" src="'+n("da21")+'" alt="Modelo ER Receta - Ingrediente">\n    <figcaption class="titulo-img">Modelo ER Receta - Ingrediente</figcaption>\n</figure>\n\n<p>Estos ejemplos son descripciones de situaciones de la vida real. Prácticamente cualquier situación puede representarse de esta manera. </p>\n<p>Pero ¿por qué es importante conocer el modelo ER? A partir de este modelo, se crean las estructuras de las bases de datos. Conocer la estructura de la base con la que trabajamos, nos facilita la escritura de consultas con SQL.</p>\n<h2 id="¿cómo-pasar-del-modelo-er-a-tablas-de-una-base-de-datos-relacional">¿Cómo pasar del modelo ER a tablas de una base de datos relacional?</h2>\n<p>Una base de datos está formada principalmente por tablas que a su vez, están formadas por filas y columnas. Puedes imaginar una tabla igual a una hoja de Excel. </p>\n<p>La información que contiene una tabla de una base de datos, es información que está relacionada entre sí. <strong>Una tabla de una base de datos corresponte a una entidad del modelo ER</strong>.</p>\n<ol>\n<li>Cada registro de una tabla (fila) constituye un individuo o miembro de una entidad. </li>\n<li>Las columnas son los atributos o campos que contienen la información específica de un registro. </li>\n<li>Cada registro posee además un identificador único (ID) que llamamos <em>clave primaria</em>. La clave primaria es la que permite <em>relacionar</em> los registros de diferentes tablas.</li>\n</ol>\n<p>En cuanto a las relaciones del modelo ER, las tratamos según su tipo:</p>\n<ol>\n<li>Las relaciones <em>0 a 1</em>, <em>1 a 1</em>, <em>0 a n</em> ó <em>1 a n</em>, se traducen por la inclusión de un atributo o columna suplementaria en la tabla hija que contiene la clave primaria del registro padre. A esta columna de la tabla hija, se le llama <em>clave foránea</em></li>\n<li>Las relaciones m a n, se traducen en una nueva tabla que contien al menos las claves primarias de las tablas relacionadas</li>\n</ol>\n<p>Así, al traducir los ejemplos anteriores de modelos ER, obtenemos los siguientes esquemas de bases de datos:</p>\n<figure>\n    <img src="'+n("1551")+'" alt="Tablas base Casas">\n    <figcaption class="titulo-img">Tablas base Casas</figcaption>\n</figure>\n\n<figure>\n    <img src="'+n("a532")+'" alt="Tablas base Artículos">\n    <figcaption class="titulo-img">Tablas base Artículos</figcaption>\n</figure>\n\n<figure>\n    <img src="'+n("5a53")+'" alt="Tablas base Recetas">\n    <figcaption class="titulo-img">Tablas base Recetas</figcaption>\n</figure>\n\n<p>Cada entidad corresponde a una tabla. </p>\n<p>En los 2 primeros casos, la relación se traduce por una columna suplementaria en la tabla hija y que corresponde a la calve primaria (identificador único) de la entidad padre.</p>\n<p>En el tercer caso, al tratarse de una relación <em>muchos a muchos</em>, la relación se traduce por una tabla suplementaria, donde están al menos las claves primarias de las 2 entidades relacionadas.</p>\n<h2 id="y-en-la-práctica-¿cómo-hacemos">Y en la práctica ¿cómo hacemos?</h2>\n<ol>\n<li>Comienza reflexionando y creando tu modelo entidad-relación. Existen muchas herramientas que te pueden ayudar, como <a href="https://www.lucidchart.com/pages/" target="_blank">Lucidchart</a> o <a href="https://erdplus.com/" target="_blank">ERDPlus</a> que oncluso pueden generar las instrucciones SQL necesarias para crear tu base de datos. Te permiten conectarte a algunos de los gestores de bases de datos más importantes como MySQL, Oracle, PostgreSQL... para ejecutar las modificaciones de tu esquema o recuperar el esquema existente</li>\n<li>Si no tienes un gestor de base de datos, utiliza SQLite, que es liviano y gratuito, ideal para practicar o incluso para utilizar en pequeñas aplicaciones</li>\n<li>Utiliza un IDE como <a href="https://dbeaver.io/" target="_blank">DBeaver</a> para conectarte a tu base de datos existente y recuperar su diagrama, modificar o crear nuevas tables, ejecutar consultas, importar y exportar datos, etc.</li>\n<li>Cuando ya domines mejor el SQL, podrás utilizar la consola directamente para manipular tu base de datos</li>\n</ol>\n<h2 id="conclusión">Conclusión:</h2>\n<p>Las bases de datos se utilizan para almacenar y gestionar información. Pero la información no debe almacenarse de cualquier manera. Utilizamos el Modelo Entidad-Relación para plasmar una parte del mundo real y traducirlo en tablas, registros y atributos de una base de datos.</p>\n<p>Muchas veces los problemas de performance, corrupción de datos o la dificultad para extraerlos, son consecuencia de un mal diseño de la base. Por eso, es importante tomarse el tiempo de reflexionar y crear un buen modelo desde el comienzo de la aplicación. Existe suficiente documentación y personas que pueden ayudarte en esta tarea.</p>\n<p>Tener un esquema de las tablas y relaciones de tu base de datos, te permitirá comprobar el funcionamiento de tu negocio y te facilitará la realización de consultas SQL, ya que sabrás qué tipo de información tienes almacenada, en qué tablas se encuentra y la mejor manera de acceder a ella.</p>\n<p>En el próximo artículo, entraremos de lleno en la escritura de consultas con SQL, a partir de preguntas funcionales.</p>\n<h2 id="artículos-relacionados">Artículos relacionados:</h2>\n<p><a href="/blog/como-hacer-consultas-sql">¿Cómo hacer consultas con SQL?</a></p>\n'},8773:function(e,a,n){"use strict";n.r(a);var o=n("7a23"),s={class:"detalle-post"};function t(e,a,n,t,r,l){return Object(o["r"])(),Object(o["e"])("div",s,[Object(o["i"])("div",{innerHTML:l.contenido,class:"markdown-body"},null,8,["innerHTML"])])}var r=n("0e54"),l=n.n(r),i=n("bc06"),c=n.n(i),d=n("7c71"),u=n.n(d),m=n("e21a"),p=n.n(m),b={name:"DetallePost",data:function(){return{markdown:{}}},created:function(){var e={"como-construir-modelo-er":u.a,"como-hacer-consultas-sql":p.a,"symbol-javascript":c.a};this.markdown=e[this.$route.params.id]},computed:{contenido:function(){return l()(this.markdown)}}};n("2d39");b.render=t;a["default"]=b},"9a1d":function(e,a,n){},a532:function(e,a,n){e.exports=n.p+"img/BD-articulo.1a2075cc.png"},bc06:function(e,a){e.exports='<h1 id="symbol-en-javascript">Symbol en Javascript</h1>\n<h6 id="14042021---d-chacón-ocariz">14/04/2021 - D. Chacón Ocariz</h6>\n<h3 id="definición">Definición</h3>\n<ul>\n<li>Tipo de dato primitivo como string, number, boolean, null y undefined</li>\n<li>Valores únicos e immutables, es decir, la función Symbol() permite obtener identificadores únicos y diferentes a los ya creados y a los por crear</li>\n<li>Se les puede agregar una descripción que facilite su identificación (recomendado)</li>\n</ul>\n<h3 id="otras-características">Otras características</h3>\n<ul>\n<li>Se debe utilizar Objeto.getOwnPropertySymbols() para poder enumerar las propiedades \nde un objeto cuyas claves son Symbol</li>\n<li>No sufren “casting ” de tipos (no se convierten implícitamente en otro tipo como string)</li>\n</ul>\n<h3 id="usos">Usos</h3>\n<ul>\n<li>Los valores únicos que se producen con Symbol() pueden ser utilizados como claves (keys) de los objetos y así poder crear nuevas propiedades sin que éstas entren en conflicto con las existentes. Ésto es particularmente útil cuando se habla de objetos “grandes” como el objeto global Wnindow</li>\n<li>Evita la sobreescritura de propiedades y métodos ya existentes</li>\n<li>Como las propiedades con claves Symbol() no son enumeradas por Objeto.keys u Objeto getOwnPropertyNames, pueden utilizarse para definir propiedades privadas</li>\n<li>Pueden utilizarse para definir una lista de constantes, ejemplo una lista de descripciones de errores</li>\n</ul>\n<h3 id="propiedades-y-métodos">Propiedades y métodos</h3>\n<table>\n<thead>\n<tr>\n<th><strong>Propiedad</strong></th>\n<th><strong>Descripción</strong></th>\n<th><strong>Ejemplo</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Symbol.length</td>\n<td>Es 0 para todos los símbolos</td>\n<td></td>\n</tr>\n<tr>\n<td><strong>Método</strong></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Symbol.for(key)</td>\n<td>Devuelve el símbolo creado con la clave dada. Si no existe, un nuevo símbolo se crea</td>\n<td>let sym = Symbol.for(&quot;nombre&quot;);</td>\n</tr>\n<tr>\n<td>Symbol.keyFor(sym)</td>\n<td>Devuelve la clave del símbolo dado</td>\n<td>console.log(Symbol.keyFor(sym)); // nombre</td>\n</tr>\n</tbody></table>\n<h3 id="símbolos-más-conocidos">Símbolos más conocidos</h3>\n<table>\n<thead>\n<tr>\n<th><strong>Symbol</strong></th>\n<th><strong>Descripción</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Symbol.hasInstance</td>\n<td>Método usado por instanceof para determinar la herencia de un objeto</td>\n</tr>\n<tr>\n<td>Symbol.iterator</td>\n<td>Método que devuelve un iterador. Los objetos que implementen la interfaz Iterable deben tener una propiedad que tenga como clave este símbolo. Dicha propiedad debe ser una función que devuelva un objeto que implemente la interfaz Iterator.  Usado por for...of.</td>\n</tr>\n<tr>\n<td>Symbol.match</td>\n<td>Método usado por String.prototype.match() para comparar strings</td>\n</tr>\n<tr>\n<td>Symbol.replace</td>\n<td>Método usado por String.prototype.replace() para reemplazar substrings</td>\n</tr>\n<tr>\n<td>Symbol.search</td>\n<td>Método usado por String.prototype.search() para buscar substrings</td>\n</tr>\n<tr>\n<td>Symbol.species</td>\n<td>Constructor utilizado para crear objetos derivados</td>\n</tr>\n<tr>\n<td>Symbol.split</td>\n<td>Método usado por String.prototype.split() para dividir strings</td>\n</tr>\n<tr>\n<td>Symbol.toPrimitive</td>\n<td>Método que devuelve una representación del valor primitivo de un objeto</td>\n</tr>\n<tr>\n<td>Symbol.toStringTag</td>\n<td>Un string utilizado por Object.prototype.toString() para crear una descripción de objeto</td>\n</tr>\n<tr>\n<td>Symbol.unscopables</td>\n<td>Un objeto cuyas propiedades son los nombres de las propiedades del objeto que no deben incluirse en una declaración with</td>\n</tr>\n</tbody></table>\n<h3 id="ejemplos">Ejemplos</h3>\n<h4 id="declaración">Declaración</h4>\n<pre><code>// Se ejecuta la función Symbol con una \n// descripción que sirve de referencia\nlet simbolo = Symbol(&quot;descripcion&quot;);\n\n// Cada ejecución de la función devuelve \n// un valor distinto\nlet x = Symbol(&quot;coordenada&quot;);\nlet y = Symbol(&quot;coordenada&quot;);\nconsole.log(x === y); // false</code></pre><h4 id="para-definir-propiedades-privadas-en-una-clase">Para definir propiedades privadas en una clase</h4>\n<pre><code>const PASSWORD = Symbol(&quot;password&quot;);\nconst ID = Symbol(&quot;id&quot;);\n\nclass Persona {\n  constructor(nombre, apellido, email) {\n    this[ID] = 1;\n    this.nombre = nombre;\n    this.id = 4;\n    this.apellido = apellido;\n    this.email = email;\n    this[PASSWORD] = &quot;generatedPassword&quot;;\n  }\n  getInfoPersona() {\n    console.log(this[ID]); // 1\n    console.log(this.id); // 4\n    return {\n      detalles: &quot;Más detalles&quot;,\n    };\n  }\n}</code></pre><h4 id="lista-de-constantes">Lista de constantes</h4>\n<pre><code>let VAN = Symbol(&#39;van&#39;);\nlet TRUCK = Symbol(&#39;truck&#39;);\nlet FERRY = Symbol(&#39;ferry&#39;);\n\nclass Transporte {\n  constructor(tipo) {\n    switch(tipo) {\n      case VAN:\n        //Furgoneta 300 kilos max\n        this.capacidad = 300; \n        this.nombre = &quot;Van&quot;;\n        break;\n      case TRUCK:\n        //Camión 1200 kilos max\n        this.capacidad = 1200; \n        this.nombre = &quot;Truck&quot;;\n        break;\n      case FERRY:\n        //Furgoneta 5000 kilos max\n        this.capacidad = 5000; \n        this.nombre = &quot;Ferry&quot;;\n        break;\n      default:\n        throw new TypeError(&#39;Tipo de transporte incorrecto&#39;);\n    }\n  }\n  toString() {\n    return `Transporte ${this.nombre} capacidad ${this.capacidad}`;\n  }\n}</code></pre><h4 id="clave-con-el-mismo-nombre-de-una-función">Clave con el mismo nombre de una función</h4>\n<pre><code>const hasOwnProperty = Symbol(&quot;hasOwnProperty&quot;);\n\nlet map = {\n    prop1: 1,\n    prop2: 2,\n    prop3: 3,\n    [hasOwnProperty]: &quot;Símbolo&quot;\n}\n\n// &quot;Símbolo&quot;\nconsole.log(map[hasOwnProperty]); \n// String\nconsole.log(typeof map[hasOwnProperty]); \n// Lamado de la función hasOwnProperty, devuelve true\nconsole.log(map.hasOwnProperty(&quot;prop1&quot;)); </code></pre><h4 id="symboliterator">Symbol.iterator</h4>\n<pre><code>let iterador = grupo.elementos[Symbol.iterator]();\nfor (let elemento of grupo) {\n    console.log(elemento);\n}</code></pre>'},d755:function(e,a,n){e.exports=n.p+"img/ER-articulo.19536040.png"},da21:function(e,a,n){e.exports=n.p+"img/ER-receta.16d95bcb.png"},e21a:function(e,a,n){e.exports='<h1 id="¿cómo-hacer-consultas-con-sql">¿Cómo hacer consultas con SQL?</h1>\n<h6 id="20102021---d-chacón-ocariz">20/10/2021 - D. Chacón Ocariz</h6>\n<p>Cuando tienes una base de datos relacional y deseas hacer una consulta, debes utilizar la instrucción <strong>SELECT</strong>.</p>\n<p>Una instrucción SELECT en SQL permite extraer datos de una o varias tablas de una base de datos relacional. En vista de que el lenguaje SQL es un lenguaje declarativo, la instrucción SELECT lo que hace es especificar el resultado que queremos obtener, y no la manera como lo vamos a obtener. Es el motor de la base de datos el que se encarga de crear el mejor plan de ejecución posible para poder obtener el resultado que le pedimos.</p>\n<p>La instrucción <strong>SELECT</strong> está formada por varias partes o cláusulas, algunas obligatorias y otras opcionales, que deben seguir un orden específico y que responden cada una a una pregunta específica:</p>\n<ol>\n<li>Las cláusulas <strong>SELECT</strong> y <strong>FROM</strong> son obligatorias. Lo mínimo que necesitas para hacer una consulta es indicar los datos que deseas y en qué tablas se encuentran. En la cláusula FROM especificas también los <strong>JOIN</strong>, es decir, la manera como vas a unir las tablas para poder obtener la información que deseas</li>\n<li>La cláusula <strong>WHERE</strong> te permite indicar las condiciones para filtrar los datos de las tablas</li>\n<li>En ocasiones necesitas funciones de agregación: <strong>SUM, AVG, COUNT</strong>… para obtener la suma, el promedio, la cantidad de registros, etc. de una columna. La cláusula <strong>GROUP BY</strong> te permite indicar las columnas por las que vas a agrupar los datos para calcular las funciones de agregación. Y la cláusula <strong>HAVING</strong> la puedes comparar con WHERE, pero para aplicar condiciones sobre las columnas calculadas con las funciones de agregación</li>\n<li><strong>ORDER BY</strong> te indica las columnas por las que quieres organizar el resultado. Por defecto el orden es ascendente</li>\n<li>Y la cláusula <strong>LIMIT</strong> la puedes utilizar para limitar la cantidad de registros que deseas obtener. Generalmente la utilizas en bases de datos con una gran cantidad de registros y cuando no necesitas tenerlos todos</li>\n</ol>\n<p>En resumen, al construir una consulta SELECT, puedes guiarte por las siguientes preguntas:</p>\n<ul>\n<li><strong>¿Qué información necesito?:</strong> <strong>SELECT</strong> </li>\n<li><strong>¿En cuál(es) tabla(s) se encuentra?:</strong> <strong>FROM</strong> </li>\n<li><strong>¿Qué condiciones deben cumplir los registros?</strong> <em>WHERE</em> </li>\n<li><strong>¿Por cuál información voy a agrupar los datos?</strong> <em>GROUP BY</em></li>\n<li><strong>¿Qué condición deben cumplir los datos agrupados?</strong> <em>HAVING</em> </li>\n<li><strong>¿Cuál será el orden del resultado?</strong> <em>ORDER BY</em> </li>\n<li><strong>¿Cuántos registros necesito?</strong> <em>LIMIT</em></li>\n</ul>\n<h2 id="caso-de-estudio-clientes-bancarios-y-sus-cuentas">Caso de estudio: Clientes bancarios y sus cuentas</h2>\n<p>Me pasaron estos ejercicios para resolverlos con Javascript. Son excelentes para practicar con arreglos y objetos, pero sin duda son muy buenos también para practicar SQL (la prueba de que siempre hay muchas maneras de solucionar un mismo problema).</p>\n<p>Comencemos por hablar del negocio:</p>\n<p>Se trata de una base de datos relacional que almacena información sobre bancos, sus clientes y las transacciones que éstos realizan.</p>\n<p>Un banco posee n clientes. Un cliente puede realizar varias transacciones en varios bancos. Se trata de una relación <strong>muchos a muchos</strong> que se traduce en 3 tablas a nivel de la base de datos:</p>\n<figure>\n    <img class="img-art" src="'+n("f992")+'" alt="Clientes y sus transacciones bancarias">\n    <figcaption class="titulo-img">Clientes y sus transacciones bancarias</figcaption>\n</figure>\n\n<p>Según el modelo Entidad - Relación, las entidades principales son <em>Clients</em> y <em>Banks</em>. Clients <em>realizan transacciones en</em> Banks, es la relación que une a estas dos entidades. Esta relación, al ser muchos a muchos, se traduce en una tabla suplementaria en la base de datos, la tabla <em>Accounts</em></p>\n<p>Tener conocimiento del esquema de la base de datos, facilita la escritura de las consultas, pues tienes más claro la información que está almacenada, en cuáles tablas debes buscarla, cuál es la relación entre las tablas…  Si no tienes un esquema de tu base de datos, puedes buscar en Google alguna herramienta que te lo genere. </p>\n<p>Si deseas saber cómo se realiza un esquema de base de datos, te recomiendo mi artículo <a href="/blog/como-construir-modelo-er">¿Cómo construir tu base de datos relacional?</a>.</p>\n<p>Aunque el modelo del ejemplo es sencillo, permite realizar una serie de consultas bastante interesantes. Con cada nueva pregunta, iremos aumentando el grado de dificultad.</p>\n<p>Aquí en mi <a href="https://github.com/dchaconoca/SQLAlchemy-SQL" target="_blank">Github</a> puedes descargar la base de datos SQLite para probar los ejemplos. También podrás encontrar allí mismo unos archivos JSON con los datos y una pequeña aplicación en Python que utiliza la librería SQLAlchemy para crear la base de datos e integrar los datos para la prueba.</p>\n<p>¡Ahora sí! Vamos a aplicar la teoría que aprendimos más arriba.</p>\n<h3 id="ejercicio-1-lista-del-nombre-y-número-fiscal-de-todos-los-clientes-ordenados-por-el-número-fiscal-ascendente">Ejercicio 1: Lista del nombre y número fiscal de todos los clientes ordenados por el número fiscal ascendente:</h3>\n<p>Como son los primeros ejercicios, podemos guiarnos por la tabla de preguntas, con el tiempo y la práctica seguro lo harás mentalmente.</p>\n<ul>\n<li><strong>¿Qué información necesito?</strong> SELECT name, taxNumber </li>\n<li><strong>¿En cuál(es) tabla(s) se encuentra?</strong> FROM Clients </li>\n<li><strong>¿Cuál será el orden del resultado?</strong> ORDER BY taxNumber </li>\n</ul>\n<p>La consulta resultante es entonces:</p>\n<pre><code>SELECT name, taxNumber \nFROM Clients\nORDER BY taxNumber</code></pre><p>No tenemos que aplicar ninguna condición WHERE porque queremos todos los registros. Por defecto el orden es ascendente, por eso tampoco hay necesidad de especificarlo.</p>\n<h3 id="ejercicio-2-todos-los-clientes-con-su-saldo-total-ordenados-por-saldo-decreciente">Ejercicio 2: Todos los clientes con su saldo total, ordenados por saldo decreciente</h3>\n<p>El nombre del cliente lo encontramos en la tabla <em>Clients</em> pero el saldo lo encontramos en la tabla <em>Accounts</em>, por lo tanto utilizamos <strong>JOIN ... ON ...</strong> para indicar cuáles tablas vamos a necesitar y a través de qué campos vamos a hacer el enlace.</p>\n<p>El saldo total no se guarda en la base, porque cambia constantemente. Así que debemos calcularlo cada vez que lo necesitamos. Para eso, utilizamos la función <strong>SUM</strong>. Y como debemos hacer el cálculo para cada cliente, debemos indicarlo en la cláusula <strong>GROUP BY</strong></p>\n<ul>\n<li><strong>¿Qué información necesito?</strong>  SELECT cl.id, cl.name, sum(ac.balance) </li>\n<li><strong>¿En cuál(es) tabla(s) se encuentra?</strong>  FROM Clients cl JOIN Accounts ac ON cl.id = ac.clientId </li>\n<li><strong>¿Por cuál información voy a agrupar los datos?</strong>  GROUP BY cl.id </li>\n<li><strong>¿Cuál será el orden del resultado?</strong> ORDER BY sum(ac.balance) DESC</li>\n</ul>\n<pre><code>SELECT cl.id, cl.name, \n  sum(ac.balance)\nFROM Clients cl JOIN Accounts ac \n  ON cl.id = ac.clientId\nGROUP BY cl.id  \nORDER BY sum(ac.balance) DESC</code></pre><h3 id="ejercicio-3-bancos-con-sus-clientes-y-sus-taxnumber-ordenados-por-nombre-del-banco-y-nombre-de-los-clientes">Ejercicio 3: Bancos con sus clientes y sus taxNumber ordenados por nombre del banco y nombre de los clientes</h3>\n<p>En este caso, necesitamos información de las 3 tablas:</p>\n<ul>\n<li><strong>¿Qué información necesito?</strong> SELECT DISTINCT bk.name, cl.name, cl.taxNumber </li>\n<li><strong>¿En cuál(es) tabla(s) se encuentra?</strong> FROM Banks bk JOIN Accounts ac ON bk.id = ac.bankId JOIN Clients cl ON cl.id = ac.clientId </li>\n<li><strong>¿Cuál será el orden del resultado?</strong>  ORDER BY bk.name, cl.name </li>\n</ul>\n<p>Utilizamos <strong>DISTINCT</strong>, de lo contrario obtendremos tantas líneas como registros hay en la tabla <em>Accounts</em>. Haz la prueba y verás.</p>\n<pre><code>SELECT DISTINCT bk.name, \n  cl.name, \n  cl.taxNumber\nFROM Banks bk JOIN Accounts ac \n  ON bk.id = ac.bankId \nJOIN Clients cl \n  ON cl.id = ac.clientId\nORDER BY bk.name, cl.name</code></pre><h3 id="ejercicio-4-clientes-del-banco-santander-con-un-saldo-mayor-a-25000-ordenados-por-saldo-decreciente">Ejercicio 4: Clientes del banco Santander con un saldo mayor a 25000 ordenados por saldo decreciente</h3>\n<p>Primero que nada, debemos calcular el saldo total para cada cliente, como lo hicimos en el ejercicio 2. Sin embargo, tenemos una condición sobre ese saldo total, pues queremos sólo aquellos clientes cuyo saldo sea mayor de 25000. Para eso, utilizamos la cláusula <strong>HAVING</strong>. Esta cláusula permite indicar condiciones sobre los campos producto de una función de agregación, en este caso <strong>SUM</strong>.</p>\n<p>Para facilitar la consulta, utilizamos directamente el identificador (ID) del banco Santander (ac.bankId = 1) en la cláusula <strong>WHERE</strong> para indicar que sólo queremos los clientes del banco Santander.</p>\n<ul>\n<li><strong>¿Qué información necesito?</strong>  SELECT cl.id, cl.name, sum(ac.balance) </li>\n<li><strong>¿En cuál(es) tabla(s) se encuentra?</strong>  FROM Clients cl JOIN Accounts ac ON cl.id = ac.clientId </li>\n<li><strong>¿Qué condiciones deben cumplir los registros?</strong>  WHERE ac.bankId = 1</li>\n<li><strong>¿Por cuál información voy a agrupar los datos?</strong>  GROUP BY cl.id </li>\n<li><strong>¿Qué condición deben cumplir los datos agrupados?</strong>  HAVING sum(ac.balance) &gt;= 25000 </li>\n<li><strong>¿Cuál será el orden del resultado?</strong>  ORDER BY sum(ac.balance) DESC </li>\n</ul>\n<pre><code>SELECT cl.id, \n  cl.name, \n  sum(ac.balance)\nFROM Clients cl JOIN Accounts ac \n  ON cl.id = ac.clientId\nWHERE ac.bankId = 1\nGROUP BY cl.id \nHAVING sum(ac.balance) &gt;= 25000\nORDER BY sum(ac.balance) DESC</code></pre><p><strong>¡Atención!</strong> Lo más importante de esta consulta, es aprender la diferencia entre <strong>WHERE</strong> y <strong>HAVING</strong>. Las 2 cláusulas permiten indicar condiciones o filtros sobre los registros, sin embargo, <em>WHERE</em> se aplica directamente a los registros de las tablas, pero <em>HAVING</em> sirve para aplicar condiciones sobre las columnas calculadas.</p>\n<h3 id="ejercicio-5-bancos-con-el-total-de-dinero-que-manejan-ordenados-crecientemente">Ejercicio 5: Bancos con el total de dinero que manejan ordenados crecientemente</h3>\n<p>Esta consulta es muy similar a la ya realizada para obtener el saldo total de cada cliente (ejercicio 2), pero en este caso, cambiamos la tabla <em>Clients</em> por la tabla <em>Banks</em>.</p>\n<ul>\n<li><strong>¿Qué información necesito?</strong>  SELECT bk.id, bk.name, sum(ac.balance) </li>\n<li><strong>¿En cuál(es) tabla(s) se encuentra?</strong>  FROM Banks bk JOIN Accounts ac ON bk.id = ac.bankId </li>\n<li><strong>¿Por cuál información voy a agrupar los datos?</strong>  GROUP BY bk.id </li>\n<li><strong>¿Cuál será el orden del resultado?</strong>  ORDER BY sum(ac.balance) </li>\n</ul>\n<pre><code>SELECT bk.id, \n  bk.name, \n  sum(ac.balance)\nFROM Banks bk JOIN Accounts ac \n  ON bk.id = ac.bankId\nGROUP BY bk.id\nORDER BY sum(ac.balance) </code></pre><h3 id="ejercicio-6-bancos-y-sus-clientes-con-el-saldo-total-de-cada-uno">Ejercicio 6: Bancos y sus clientes con el saldo total de cada uno</h3>\n<p>Aquí unimos lo que ya hicimos en los ejercicios 2 y 5. </p>\n<pre><code>SELECT bk.name, \n  cl.name, \n  sum(ac.balance)\nFROM Banks bk JOIN Accounts ac \n  ON bk.id = ac.bankId\nJOIN Clients cl \n  ON ac.clientId = cl.id \nGROUP BY bk.name, cl.name</code></pre><h3 id="ejercicio-7-bancos-con-la-cantidad-de-clientes-que-solo-tienen-cuenta-en-ese-banco">Ejercicio 7: Bancos con la cantidad de clientes que solo tienen cuenta en ese banco</h3>\n<p>Para cada banco, contamos la cantidad de clientes distintos que tiene. <em>Excluimos</em> los clientes que tienen cuenta en otro banco (NOT IN subconsulta).</p>\n<pre><code>SELECT ac.bankId, \n  count(DISTINCT ac.clientId)\nFROM Accounts ac\nWHERE ac.clientId NOT IN \n  (SELECT ac2.clientId \n  FROM Accounts ac2 \n  WHERE ac.bankId &lt;&gt; ac2.bankId)\nGROUP BY ac.bankId</code></pre><p>Analicemos la consulta: </p>\n<ol>\n<li>Tenemos una consulta principal (primer SELECT) y una subconsulta o consulta secundaria (segundo SELECT)</li>\n<li>En la subconsulta, buscamos los clientes que tienen transacciones en otro banco que no sea el banco de la consulta principal, eso es lo que expresamos con la cláusula <strong>WHERE ac.bankId &lt;&gt; ac2.bankId</strong>. </li>\n<li>Luego, en la consulta principal, excluimos todos los clientes encontrados en la subconsulta (NOT IN).</li>\n</ol>\n<p>Puedes utilizar la siguiente consulta para identificar los clientes que solo tienen una cuenta en un banco:</p>\n<pre><code>SELECT ac.bankId, \n  ac.clientId\nFROM Accounts ac\nWHERE ac.clientId NOT IN \n  (SELECT ac2.clientId \n  FROM Accounts ac2 \n  WHERE ac.bankId &lt;&gt; ac2.bankId)\nGROUP BY ac.bankId</code></pre><h3 id="ejercicio-8-bancos-con-el-cliente-de-menor-saldo">Ejercicio 8: Bancos con el cliente de menor saldo</h3>\n<p>Esta consulta debemos hacerla en 2 partes: Una que nos devuelve el saldo total para cada cliente en cada banco y otra parte que selecciona el cliente con el saldo más pequeño.</p>\n<p>Aquí te presento 3 soluciones:</p>\n<h4 id="solución-con-una-subconsulta">Solución con una subconsulta:</h4>\n<p>Podemos utilizar una consulta con una subconsulta. La subconsulta nos devuelve los ID del banco, del cliente y el saldo total de cada cliente en el banco dado.</p>\n<p>Luego, la consulta principal selecciona el cliente con el saldo más pequeño (<strong>min(total)</strong>).</p>\n<pre><code>SELECT bk.name, \n  cl.name, \n  min(total)\nFROM Banks bk JOIN \n  (SELECT ac.bankId AS bankId, \n    ac.clientId AS clientId, \n    sum(ac.balance) AS total\n  FROM Accounts ac\n  GROUP BY ac.bankId, ac.clientId) \nON bk.id = bankId \nJOIN Clients cl \n  ON clientId = cl.id\nGROUP BY bankId </code></pre><p>En este caso, la subconsulta la asimilamos a una tabla, por eso la incluimos en un JOIN.</p>\n<p>Esta solución no es la más óptima, ya que el código es más difícil de comprender. </p>\n<h4 id="solución-con-una-cte">Solución con una CTE:</h4>\n<p>Las <strong>Common Table Expression (CTE)</strong> o <strong>Expresiones Comunes de Tabla</strong> permiten definir una consulta que luego podrá ser utilizada dentro de otra instrucción. Facilitan la escritura de consultas complejas y son temporales.</p>\n<pre><code>WITH TotalBalanceBankClient AS\n( SELECT ac.bankId AS bankId, \n    ac.clientId AS clientId,\n    sum(ac.balance) AS total\n  FROM Accounts ac\n  GROUP BY ac.bankId, ac.clientId)\n\nSELECT bk.name, cl.name, min(tb.total)\nFROM Banks bk JOIN TotalBalanceBankClient tb \n  ON bk.id = tb.bankId \nJOIN Clients cl ON tb.clientId = cl.id\nGROUP BY tb.bankId </code></pre><p>Las CTE son sin duda una mejor solución que la utilización de subconsultas, no solo porque facilitan la lectura y comprensión de consultas complejas, también tienen un mejor performance en caso de que una misma consulta se utilice varias veces en un mismo bloque.</p>\n<h4 id="solución-con-una-vista">Solución con una Vista:</h4>\n<p>Otra solución es crear una <strong>Vista</strong> (CREATE VIEW) con la subconsulta de la solución y luego utilizarla dentro de la consulta principal.</p>\n<p>Las vistas son una especie de tablas virtuales que se crean a partir de una consulta SQL. Tienen la ventaja de facilitar la escritura de consultas complejas, haciéndolas más lisibles, comprensibles y reutilizables en varias consultas.</p>\n<pre><code>CREATE VIEW TotalBalanceBankClient AS\n  SELECT ac.bankId AS bankId, \n    ac.clientId AS clientId,\n    sum(ac.balance) AS total\n  FROM Accounts ac\n  GROUP BY ac.bankId, ac.clientId</code></pre><pre><code>SELECT bk.name, cl.name, min(tb.total)\nFROM Banks bk JOIN TotalBalanceBankClient tb \n  ON bk.id = tb.bankId \nJOIN Clients cl ON tb.clientId = cl.id\nGROUP BY tb.bankId </code></pre><p>La ventaja de las vistas sobre las CTE es que son elementos que existen dentro de la base de datos y pueden ser utilizdas en diferentes instrucciones. </p>\n<p><strong>¿Cuál de las 3 soluciones te parece más sencilla de realizar / comprender?</strong></p>\n<h2 id="conclusión">Conclusión:</h2>\n<p>El SQL es un lenguaje declarativo, es decir, lo que hacemos es indicar el resultado que queremos obtener, luego el motor de la base de datos es el encargado de &quot;decidir&quot; cómo hacer la ejecución.</p>\n<p>Conocer el esquema de una base de datos te facilita la realización de consultas, ya que tienes más claro que información tienes y en qué tabla se encuentra.</p>\n<p>Aquí presentamos solo unos cuantos ejercicios, queda de tu parte seguir practicando y estudiando este maravilloso lenguaje. Aquí te dejo algunos cursos:</p>\n<ul>\n<li><a href="https://www.w3schools.com/sql/default.asp" target="_blank">W3School</a></li>\n<li><a href="https://www.datacamp.com/search?q=&tab=courses&facets%5Btechnology%5D%5B%5D=SQL" target="_blank">DataCamp</a></li>\n<li><a href="https://www.youtube.com/playlist?list=PLU8oAlHdN5Bmx-LChV4K3MbHrpZKefNwn" target="_blank">PildorasInformaticas</a></li>\n<li><a href="https://mystery.knightlab.com/" target="_blank">SQL Murder Mystery</a></li>\n</ul>\n<h2 id="artículos-relacionados">Artículos relacionados:</h2>\n<p><a href="/blog/como-construir-modelo-er">¿Cómo construir tu base de datos relacional?</a></p>\n'},f992:function(e,a,n){e.exports=n.p+"img/ER-banco.7412ea15.png"}}]);
//# sourceMappingURL=chunk-1f598066.7a4f1a9e.js.map