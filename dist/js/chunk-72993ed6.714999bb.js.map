{"version":3,"sources":["webpack:///./src/views/blog/ES/ES-sql.md","webpack:///./src/views/DetallePosts.vue","webpack:///./src/views/DetallePosts.vue?03cc","webpack:///./src/views/blog/ES/ES-symbols.md","webpack:///./src/views/DetallePosts.vue?d972"],"names":["module","exports","class","contenido","name","data","markdown","created","recursos","this","$route","params","id","computed","render"],"mappings":"4HAAAA,EAAOC,QAAU,ggE,4DCCVC,MAAM,gB,gDAAX,eAEM,MAFN,EAEM,CADJ,eAA+C,OAA1C,UAAQ,EAAAC,UAAWD,MAAM,iB,2FAWnB,GACbE,KAAM,cACNC,KAFa,WAGX,MAAO,CACLC,SAAU,KAGdC,QAPa,WAQX,IAAIC,EAAW,CACb,KAAQ,IACR,KAAQ,IACR,QAAW,KAGbC,KAAKH,SAAWE,EAASC,KAAKC,OAAOC,OAAOC,KAE9CC,SAAU,CACNV,UADM,WAEJ,OAAO,IAAOM,KAAKH,a,UC1B3B,EAAOQ,OAASA,EAED,gB,mBCPfd,EAAOC,QAAU,ynM,kCCAjB","file":"js/chunk-72993ed6.714999bb.js","sourcesContent":["module.exports = \"<h1 id=\\\"¿cómo-hacer-consultas-con-sql-parte-i\\\">&quot;¿Cómo hacer consultas con SQL?&quot; Parte I</h1>\\n<h4 id=\\\"javascript\\\">Javascript</h4>\\n<pre><code>// Se ejecuta la función Symbol con una descripción que sirve de referencia\\nlet simbolo = Symbol(&quot;descripcion&quot;);\\n// Cada ejecución de la función devuelve un valor distinto\\nlet x = Symbol(&quot;coordenada&quot;);\\nlet y = Symbol(&quot;coordenada&quot;);\\nconsole.log(x === y); // false</code></pre><h4 id=\\\"sql\\\">SQL</h4>\\n<pre><code>SELECT * FROM categoria;</code></pre><h4 id=\\\"html\\\">HTML</h4>\\n<pre><code>&lt;div class=&quot;form-group row&quot;&gt;\\n    &lt;label for=&quot;descripcion&quot; class=&quot;col-sm-2 col-form-label&quot;&gt;Descripción&lt;/label&gt;\\n    &lt;div class=&quot;col-sm-10&quot;&gt;\\n        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;descripcion&quot; name=&quot;descripcion&quot; maxlength=100\\n        value={% if accion == &quot;Crear&quot; %} &quot;&quot; {% else %} &quot;{{ ingrediente.descripcion }}&quot; {% endif %} &gt;\\n    &lt;/div&gt;\\n&lt;/div&gt;</code></pre><h4 id=\\\"css\\\">CSS</h4>\\n<pre><code>.contenedor {\\n    position: relative;\\n    display: inline;\\n    margin: 0; \\n    padding: 0; \\n    border: 0;\\n}</code></pre><h4 id=\\\"python\\\">Python</h4>\\n<pre><code>  # Guarda un ingrediente, ya sea nuevo o existente (id)\\n  def guardar(self):\\n    if not self.id:\\n      self.created=datetime.now()\\n      self.updated=datetime.now()\\n      db.session.add(self)\\n    else:\\n      ingrediente = {&#39;nombre&#39;: self.nombre, \\n                    &#39;descripcion&#39;: self.descripcion,\\n                    &#39;precio&#39;: self.precio,\\n                    &#39;medida_id&#39;: self.medida_id,\\n                    &#39;updated&#39;: datetime.now()\\n                    }\\n      self.query.filter_by(id=self.id).update(ingrediente)\\n    db.session.commit()</code></pre><p>Aquí podrán encontrar el proyecto en Flask -&gt; <a href=\\\"https://github.com/dchaconoca/Recetario-en-Flask\\\">Recetario en Flask</a></p>\\n\";","<template>\n  <div class=\"detalle-post\"> \n    <div v-html=\"contenido\" class=\"markdown-body\"/>\n  </div>\n</template>\n\n<script>\n// @ is an alias to /src\nimport marked from \"marked\";\nimport ESsymbols from \"/src/views/blog/ES/ES-symbols.md\";\nimport ESsql1 from \"/src/views/blog/ES/ES-sql.md\";\nimport ESsql2 from \"/src/views/blog/ES/ES-sql.md\";\n\nexport default {\n  name: 'DetallePost',\n  data() {\n    return {\n      markdown: {}\n    }\n  },\n  created() {\n    let recursos = {\n      'sql1': ESsql1,\n      'sql2': ESsql2,\n      'symbols': ESsymbols,\n    }\n\n    this.markdown = recursos[this.$route.params.id];\n  },\n  computed: {\n      contenido() {\n        return marked(this.markdown)\n      }\n  }\n}\n</script>\n\n<style>\n  /* No limitamos el scoop para que puedan aplicarse estilos al markdown */\n  /* Se pueden escribir etiquetas html directamente en el documento markdown y agregar clases css */\n  \n   @import '../assets/css/markdown.css';\n   @import '../assets/css/responsive.css';\n   \n\n  .img-art {\n    margin: auto;\n\t\tdisplay: block;\n    padding: 2%;\n  }\n</style>","import { render } from \"./DetallePosts.vue?vue&type=template&id=a98288c8\"\nimport script from \"./DetallePosts.vue?vue&type=script&lang=js\"\nexport * from \"./DetallePosts.vue?vue&type=script&lang=js\"\n\nimport \"./DetallePosts.vue?vue&type=style&index=0&id=a98288c8&lang=css\"\nscript.render = render\n\nexport default script","module.exports = \"<h1 id=\\\"símbolos\\\">Símbolos</h1>\\n<h3 id=\\\"definición\\\">Definición</h3>\\n<pre><code>• Tipo de dato primitivo como string, number, boolean, null y undefined\\n• Valores únicos e immutables, es decir, la función Symbol() permite obtener identificadores únicos y diferentes a los ya creados y a los por crear\\n• Se les puede agregar una descripción que facilite su identificación (recomendado)</code></pre><h3 id=\\\"otras-características\\\">Otras características</h3>\\n<pre><code>• Se debe utilizar Objeto.getOwnPropertySymbols() para poder enumerar las propiedades \\nde un objeto cuyas claves son Symbol\\n• No sufren “casting ” de tipos (no se convierten implícitamente en otro tipo como string)</code></pre><h3 id=\\\"usos\\\">Usos</h3>\\n<pre><code>• Los valores únicos que se producen con Symbol() pueden ser utilizados como claves (keys)   de los objetos y así poder crear nuevas propiedades sin que éstas entren en \\nconflicto con las existentes. Ésto es particularmente útil cuando se habla de objetos “grandes” como el objeto global Wnindow\\n• Evita la sobreescritura de propiedades y métodos ya existentes\\n• Como las propiedades con claves Symbol() no son enumeradas por Objeto.keys u Objeto.\\ngetOwnPropertyNames, pueden utilizarse para definir propiedades privadas\\n• Pueden utilizarse para definir una lista de constantes, ejemplo una lista de \\ndescripciones de errores</code></pre><h3 id=\\\"propiedades-y-métodos\\\">Propiedades y métodos</h3>\\n<table>\\n<thead>\\n<tr>\\n<th><strong>Propiedad</strong></th>\\n<th><strong>Descripción</strong></th>\\n<th><strong>Ejemplo</strong></th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td>Symbol.length</td>\\n<td>Es 0 para todos los símbolos</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><strong>Método</strong></td>\\n<td></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>Symbol.for(key)</td>\\n<td>Devuelve el símbolo creado con la clave dada. Si no existe, un nuevo símbolo se crea</td>\\n<td>let sym = Symbol.for(&quot;nombre&quot;);</td>\\n</tr>\\n<tr>\\n<td>Symbol.keyFor(sym)</td>\\n<td>Devuelve la clave del símbolo dado</td>\\n<td>console.log(Symbol.keyFor(sym)); // nombre</td>\\n</tr>\\n</tbody></table>\\n<h3 id=\\\"símbolos-más-conocidos\\\">Símbolos más conocidos</h3>\\n<table>\\n<thead>\\n<tr>\\n<th><strong>Symbol</strong></th>\\n<th><strong>Descripción</strong></th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td>Symbol.hasInstance</td>\\n<td>Método usado por instanceof para determinar la herencia de un objeto</td>\\n</tr>\\n<tr>\\n<td>Symbol.iterator</td>\\n<td>Método que devuelve un iterador. Los objetos que implementen la interfaz Iterable deben tener una propiedad que tenga como clave este símbolo. Dicha propiedad debe ser una función que devuelva un objeto que implemente la interfaz Iterator.  Usado por for...of.</td>\\n</tr>\\n<tr>\\n<td>Symbol.match</td>\\n<td>Método usado por String.prototype.match() para comparar strings</td>\\n</tr>\\n<tr>\\n<td>Symbol.replace</td>\\n<td>Método usado por String.prototype.replace() para reemplazar substrings</td>\\n</tr>\\n<tr>\\n<td>Symbol.search</td>\\n<td>Método usado por String.prototype.search() para buscar substrings</td>\\n</tr>\\n<tr>\\n<td>Symbol.species</td>\\n<td>Constructor utilizado para crear objetos derivados</td>\\n</tr>\\n<tr>\\n<td>Symbol.split</td>\\n<td>Método usado por String.prototype.split() para dividir strings</td>\\n</tr>\\n<tr>\\n<td>Symbol.toPrimitive</td>\\n<td>Método que devuelve una representación del valor primitivo de un objeto</td>\\n</tr>\\n<tr>\\n<td>Symbol.toStringTag</td>\\n<td>Un string utilizado por Object.prototype.toString() para crear una descripción de objeto</td>\\n</tr>\\n<tr>\\n<td>Symbol.unscopables</td>\\n<td>Un objeto cuyas propiedades son los nombres de las propiedades del objeto que no deben incluirse en una declaración with</td>\\n</tr>\\n</tbody></table>\\n<h3 id=\\\"ejemplos\\\">Ejemplos</h3>\\n<h4 id=\\\"declaración\\\">Declaración</h4>\\n<pre><code>// Se ejecuta la función Symbol con una descripción que sirve de referencia\\nlet simbolo = Symbol(&quot;descripcion&quot;);\\n\\n// Cada ejecución de la función devuelve un valor distinto\\nlet x = Symbol(&quot;coordenada&quot;);\\nlet y = Symbol(&quot;coordenada&quot;);\\nconsole.log(x === y); // false</code></pre><h4 id=\\\"para-definir-propiedades-privadas-en-una-clase\\\">Para definir propiedades privadas en una clase</h4>\\n<pre><code>const PASSWORD = Symbol(&quot;password&quot;);\\nconst ID = Symbol(&quot;id&quot;);\\n\\nclass Persona {\\n  constructor(nombre, apellido, email) {\\n    this[ID] = 1;\\n    this.nombre = nombre;\\n    this.id = 4;\\n    this.apellido = apellido;\\n    this.email = email;\\n    this[PASSWORD] = &quot;generatedPassword&quot;;\\n  }\\n  getInfoPersona() {\\n    console.log(this[ID]); // 1\\n    console.log(this.id); // 4\\n    return {\\n      detalles: &quot;Más detalles&quot;,\\n    };\\n  }\\n}</code></pre><h4 id=\\\"lista-de-constantes\\\">Lista de constantes</h4>\\n<pre><code>let VAN = Symbol(&#39;van&#39;);\\nlet TRUCK = Symbol(&#39;truck&#39;);\\nlet FERRY = Symbol(&#39;ferry&#39;);\\n\\nclass Transporte {\\n  constructor(tipo) {\\n    switch(tipo) {\\n      case VAN:\\n        this.capacidad = 300; //Furgoneta 300 kilos max\\n        this.nombre = &quot;Van&quot;;\\n        break;\\n      case TRUCK:\\n        this.capacidad = 1200; //Camión 1200 kilos max\\n        this.nombre = &quot;Truck&quot;;\\n        break;\\n      case FERRY:\\n        this.capacidad = 5000; //Furgoneta 5000 kilos max\\n        this.nombre = &quot;Ferry&quot;;\\n        break;\\n      default:\\n        throw new TypeError(&#39;Tipo de transporte incorrecto&#39;);\\n    }\\n  }\\n  toString() {\\n    return `Transport type ${this.nombre} with capacity ${this.capacidad}`;\\n  }\\n}</code></pre><h4 id=\\\"clave-con-el-mismo-nombre-de-una-función\\\">Clave con el mismo nombre de una función</h4>\\n<pre><code>const hasOwnProperty = Symbol(&quot;hasOwnProperty&quot;);\\n\\nlet map = {\\n    prop1: 1,\\n    prop2: 2,\\n    prop3: 3,\\n    [hasOwnProperty]: &quot;Símbolo&quot;\\n}\\n\\nconsole.log(map[hasOwnProperty]); // &quot;Símbolo&quot;\\nconsole.log(typeof map[hasOwnProperty]); // String\\nconsole.log(map.hasOwnProperty(&quot;prop1&quot;)); // Lamado de la función hasOwnProperty, devuelve true</code></pre><h4 id=\\\"symboliterator\\\">Symbol.iterator</h4>\\n<pre><code>let iterador = grupo.elementos[Symbol.iterator]();\\nfor (let elemento of grupo) {\\n    console.log(elemento);\\n}</code></pre>\";","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--6-oneOf-1-1!../../node_modules/vue-loader-v16/dist/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader-v16/dist/index.js??ref--0-1!./DetallePosts.vue?vue&type=style&index=0&id=a98288c8&lang=css\""],"sourceRoot":""}